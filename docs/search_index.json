[["index.html", "Fitting models using stelfi Installation", " Fitting models using stelfi Charlotte M. Jones-Todd &amp; Alec van Helsdingen Installation The stelfi package can be installed from Github: devtools::install_github(&quot;cmjt/stelfi&quot;) Compiling templates Before using the TMB templates in stelfi you should use compile_stelfi() to compile them: stelfi::compile_stelfi() "],["hawkes.html", "Chapter 1 Hawkes process 1.1 The fit_hawkes() function 1.2 The fit_hawkes_cbf() function", " Chapter 1 Hawkes process A univariate Hawkes process is defined to be a self-exciting temporal point process where the conditional intensity function is given by \\[\\lambda(t) = \\mu(t) + \\Sigma_{i:\\tau_i&lt;t}\\nu(t-\\tau_i)\\] where where \\(\\mu(t)\\) is the background rate of the process and \\(\\Sigma_{i:\\tau_i&lt;t}\\nu(t-\\tau_i)\\) is some historic temporal dependence. First introduced by Hawkes (1971), the classic homogeneous formulation is: \\[\\lambda(t) = \\mu + \\alpha \\Sigma_{i:\\tau_i&lt;t}\\text{exp}(-\\beta * (t-\\tau_i)) \\] 1.1 The fit_hawkes() function args(fit_hawkes) ## function (times, parameters = list(), model = 1, marks = c(rep(1, ## length(times))), tmb_silent = TRUE, optim_silent = TRUE, ## ...) ## NULL 1.1.1 Fitting a Hawkes model A NIWA scientist found a working USB in the scat of a leopard seal, they then tweeted about it in the hopes of finding its owner. data(retweets_niwa) head(retweets_niwa) ## [1] &quot;2019-02-07 06:50:08 UTC&quot; &quot;2019-02-07 06:50:08 UTC&quot; ## [3] &quot;2019-02-07 06:49:22 UTC&quot; &quot;2019-02-07 06:48:48 UTC&quot; ## [5] &quot;2019-02-07 06:47:52 UTC&quot; &quot;2019-02-07 06:47:42 UTC&quot; ## numeric time stamps times &lt;- unique(sort(as.numeric(difftime(retweets_niwa ,min(retweets_niwa),units = &quot;mins&quot;)))) (#fig:plot hist)Observed counts of retweet times params &lt;- c(mu = 9, alpha = 3, beta = 10) ## must have compiled TMB templates first use compile_stelfi() fit &lt;- fit_hawkes(times = times,parameters = params) ## print out estimated parameters pars &lt;- get_coefs(fit) pars ## Estimate Std. Error ## mu 0.06328099 0.017783908 ## alpha 0.07596531 0.007777899 ## beta 0.07911346 0.008109789 show_hawkes(times = times, mu = pars[1,1], alpha = pars[2,1], beta = pars[3,1]) show_hawkes_GOF(times = times, mu = pars[1,1], alpha = pars[2,1], beta = pars[3,1], return_values = FALSE) 1.1.2 Fitting an ETAS-type marked model Here we fit a univariate marked Hawkes process where the conditional intensity function is given by \\[\\lambda(t; m(t)) = \\mu + \\alpha \\Sigma_{i:\\tau_i&lt;t}m(\\tau_i)\\text{exp}(-\\beta * (t-\\tau_i)) \\] where \\(\\mu\\) is the background rate of the process and \\(m(t)\\) is the temporal mark. Each event \\(i\\) has an associated mark \\(\\tau_i\\) that multiples the self-exciting component of \\(\\lambda\\). In this example, the events are earthquakes and the marks are the Richter magnitude of each earthquake. data(&quot;earthquakes&quot;) head(earthquakes) ## origintime longitude latitude magnitude depth ## 1 2014-12-24 07:46:00 172.7133 -43.57944 3.208996 13.671875 ## 2 2014-12-24 06:43:00 172.7204 -43.55752 4.109075 5.820312 ## 3 2014-12-14 08:53:00 172.3641 -43.62563 3.240377 5.058594 ## 4 2014-12-12 13:37:00 172.3680 -43.63492 4.459034 9.394531 ## 5 2014-11-20 08:24:00 172.7836 -43.42493 3.116447 10.039062 ## 6 2014-11-18 14:19:00 172.7936 -43.48970 3.158710 11.269531 earthquakes &lt;- earthquakes[order(earthquakes$origintime),] earthquakes &lt;- earthquakes[!duplicated(earthquakes$origintime),] times &lt;- earthquakes$origintime times &lt;- as.numeric(difftime(times , min(times), units = &quot;mins&quot;)) marks &lt;- earthquakes$magnitude params &lt;- c(mu = 3, alpha = 0.05, beta = 1) ## must have compiled TMB templates first use compile_stelfi() fit &lt;- fit_hawkes(times = times, parameters = params, marks = marks) ## print out estimated parameters pars &lt;- get_coefs(fit) pars ## Estimate Std. Error ## mu 0.0002001766 1.206014e-05 ## alpha 0.0005125373 2.934243e-05 ## beta 0.0020558328 1.204552e-04 show_hawkes(times = times, mu = pars[1,1], alpha = pars[2,1], beta = pars[3,1], marks = marks) show_hawkes_GOF(times = times, mu = pars[1,1], alpha = pars[2,1], beta = pars[3,1], marks = marks, return_values = FALSE) 1.2 The fit_hawkes_cbf() function args(fit_hawkes_cbf) ## function (times, parameters = list(), model = 1, marks = c(rep(1, ## length(times))), background, background_integral, background_parameters, ## background_min, tmb_silent = TRUE, optim_silent = TRUE) ## NULL 1.2.1 Fitting an inhomogenous Hawkes process Here we fit a univariate inhomogenous marked Hawkes process where the conditional intensity function is given by \\[\\lambda(t) = \\mu(t) + \\alpha \\Sigma_{i:\\tau_i&lt;t}\\text{exp}(-\\beta * (t-\\tau_i)) \\] The background \\(\\mu(t)\\) is time varying, rather than being constant. The following example uses simulated data. set.seed(1) library(hawkesbow) # Simulate a Hawkes process with mu = 1+sin(t), alpha=1, beta =2 times &lt;- hawkesbow::hawkes(1000, fun=function(y) {1+0.5*sin(y)}, M=1.5, repr=0.5, family=&quot;exp&quot;, rate=2)$p We will attempt to recover these parameter values, modelling the background as $ (t) = A + Bsin(t)$. The background will be written as a function of \\(x\\) and \\(y\\), where \\(A = e^x\\) and \\(B= logit(y) e^x\\). This formulation ensures the background is never negative. ## The background function must take a single parameter and the time(s) at which it is evaluated background &lt;- function(params,times){ A = exp(params[[1]]) B = stats::plogis(params[[2]]) * A return(A + B*sin(times)) } ## The background_integral function must take a single parameter and the time at which it is evaluated background_integral &lt;- function(params,x){ A = exp(params[[1]]) B = stats::plogis(params[[2]]) * A return((A*x)-B*cos(x)) } param = list(alpha = 0.5, beta = 1.5) background_param = list(1,1) fit &lt;- fit_hawkes_cbf(times = times, parameters = param, background = background, background_integral = background_integral, background_parameters = background_param) The estimated values of \\(A\\) and \\(B\\) respectively are exp(fit$background_parameters[1]) ## [1] 1.025526 plogis(fit$background_parameters[2]) * exp(fit$background_parameters[1]) ## [1] 0.5635566 The estimated values of \\(\\alpha\\) and \\(\\beta\\) respectively are: ab = get_coefs(fit)[1:2,1] ab ## alpha beta ## 1.040863 2.179564 show_hawkes(obj = fit, mu = background) show_hawkes_GOF(obj = fit, mu = background_integral, return_values = FALSE) References "],["lgcp.html", "Chapter 2 A log-Gaussian Cox Process 2.1 The fit_lgcp() function", " Chapter 2 A log-Gaussian Cox Process A Log-Gaussian Cox Process (LGCP) is a doubly stochastic spatial point process. In the simplest case, the intensity of the point process over space is given by: \\[\\Lambda(s) = \\text{exp}(\\beta_0 + G(s) + \\epsilon)\\] where \\(\\beta_0\\) is a constant, known as the intercept, \\(G(s)\\) is a Gaussian Markov Random Field (GMRF) and \\(\\epsilon\\) an error term. It is conventional to use Matérn covariance function to define the covariance of the random field. This takes two parameters \\(\\tau\\) and \\(\\kappa\\), commonly reported as \\(r=\\frac{\\sqrt{8}}{\\kappa}\\) and \\(\\sigma=\\frac{1}{\\sqrt{4\\pi\\kappa^2\\tau^2}}\\), where \\(r\\) is the range and \\(\\sigma\\) is the standard deviation. 2.1 The fit_lgcp() function args(fit_lgcp) ## function (locs, sp, smesh, tmesh, parameters = list(), covariates, ## tmb_silent = TRUE, nlminb_silent = TRUE, ...) ## NULL 2.1.1 Fitting a spatial only LGCP require(maptools) data(xyt, package = &quot;stelfi&quot;) domain &lt;- as(xyt$window, &quot;SpatialPolygons&quot;) locs &lt;- data.frame(x = xyt$x, y = xyt$y) smesh &lt;- INLA::inla.mesh.2d(boundary = INLA::inla.sp2segment(domain), max.edge = 0.75, cutoff = 0.3) system.time(fit &lt;- fit_lgcp(locs = locs, sp = domain, smesh = smesh, parameters = c(beta = 0, log_tau = log(1), log_kappa = log(1)))) ## user system elapsed ## 3.861 0.159 3.975 get_coefs(fit) ## Estimate Std. Error ## beta 2.4481848 0.09034657 ## log_tau -1.3156570 0.33288053 ## log_kappa 0.9547072 0.29440167 ## range 1.0887319 0.32052449 ## stdev 0.4047190 0.05027126 plot_lambda(fit, smesh = smesh, border = domain) + ggplot2::theme_void() Comparing to inlabru require(inlabru) matern &lt;- INLA::inla.spde2.matern(smesh) cmp &lt;- coordinates ~ mySmooth(coordinates, model = matern) + Intercept(1) coordinates(locs) &lt;- c(&quot;x&quot;, &quot;y&quot;) system.time(fit_inla &lt;- lgcp(cmp, locs, samplers = domain, domain = list(coordinates = smesh), options = list(control.inla = list(int.strategy = &quot;eb&quot;)))) ## user system elapsed ## 10.367 8.594 9.370 fit_inla$summary.fixed ## mean sd 0.025quant 0.5quant 0.975quant mode kld ## Intercept 2.487269 0.139844 2.212964 2.487425 2.761685 NA 0.02828069 fit_inla$summary.hyperpar ## mean sd 0.025quant 0.5quant 0.975quant mode ## Theta1 for mySmooth -0.4212342 0.2552850 -0.9115601 -0.4261737 0.09481969 NA ## Theta2 for mySmooth 0.2192170 0.3024201 -0.3919524 0.2249611 0.80037538 NA 2.1.2 Spatiotemporal LGCP The LGCP model can also be used for spatiotemporal modelling where there is autoregressive temporal dependence. To achieve this, we choose an arbitrary number of time knots. The equation for an AR(1) process is as follows: \\[\\Lambda_i(s) = \\text{exp}(\\beta_0 + G_i(s) + \\epsilon)\\] where \\(i\\) indexes the time knot. \\(\\Lambda_i(s)\\) is the field intensity at time knot \\(i\\), and \\(G_i(s)\\) the GMRF at the same time knot. Each \\(G_i(s)\\) shares common values for \\(\\tau\\) and \\(\\kappa\\). Successive random fields are correlated through the formula \\[G_i(s)=\\rho G_{i-1}(s) + \\epsilon_i\\] where \\(\\rho\\) is a constant between -1 and +1, and \\(\\epsilon_i\\) is normally distributed with mean 0. ndays &lt;- 2 locs &lt;- data.frame(x = xyt$x, y = xyt$y, t = xyt$t) w0 &lt;- 2 tmesh &lt;- INLA::inla.mesh.1d(seq(0, ndays, by = w0)) fit &lt;- fit_lgcp(locs = locs, sp = domain, smesh = smesh, tmesh = tmesh, parameters = c(beta = 0, log_tau = log(1), log_kappa = log(1), atanh_rho = 0.2)) get_coefs(fit) ## Estimate Std. Error ## rho 0.3100841 0.20738457 ## beta 1.6852264 0.13685037 ## log_tau -1.0683016 0.22402076 ## log_kappa 0.4785904 0.22707189 ## range 1.7526525 0.39797812 ## stdev 0.5087488 0.05765947 plot_lambda(fit, smesh = smesh, tmesh = tmesh, timestamp = 1) + ggplot2::theme_void() + ggplot2::ggtitle(&quot;t = 2&quot;) plot_lambda(fit, smesh = smesh, tmesh = tmesh, timestamp = 2) + ggplot2::theme_void() + ggplot2::ggtitle(&quot;t = 2&quot;) 2.1.3 Simulating a spatiotemporal LGCP Option 1 using simulate_lgcp parameters &lt;- c(beta = 1, log_tau = log(1), log_kappa = log(1), atanh_rho = 0.2) simdata &lt;- simulate_lgcp(parameters = parameters, sp = domain, smesh = smesh, tmesh = tmesh) show_field(simdata$x[,1], smesh = smesh) + ggplot2::theme_void() Option 2 directly from the fitted model simdata &lt;- fit$simulate(fit$env$last.par, complete = FALSE) show_field(simdata$x[,1], smesh = smesh) + ggplot2::theme_void() "],["marked.html", "Chapter 3 A marked log-Gaussian Cox Process 3.1 The fit_mlgcp() function", " Chapter 3 A marked log-Gaussian Cox Process Each event in a spatial LGCP may have a scalar or vector mark associated with it. In that case, we are interested not only in the spatial intensity of the point process but also the spatial distribution of the marks and the correlation between the marks and the point process. The intensity of the LGCP is as in the simple case: \\[\\Lambda_{pp}(s) = \\text{exp}(\\beta_{pp} + G_{pp}(s) + \\epsilon)\\] note the subscripts \\(pp\\) indicating the point process. The mark(s) have their own field: \\[\\Lambda_m(s)=\\beta_{m}+G_m(s)+\\alpha \\text{log}(\\Lambda_{pp}(s)) +\\epsilon\\] where \\(\\alpha\\) are coefficient(s) linking the point process and the mark(s). The meaning of \\(\\Lambda_m(s)\\) depends on the distribution of the marks. If the marks are from a Poisson distribution, it is the intensity (as with the point process). If the marks are from a Binomial distribution, it is the success probability, and the user must supply the number of trials for each event. If the marks are normally distributed, \\(\\Lambda_m(s)\\) models the mean, and the user must supply the standard deviation. The user can choose for the point processes and the marks to share a common GMRF, i.e. \\(G_m(s) = G_{pp}(s)\\) 3.1 The fit_mlgcp() function args(fit_mlgcp) ## function (locs, sp, marks, smesh, parameters = list(), methods, ## strfixed = matrix(1, nrow = nrow(locs), ncol = ncol(marks)), ## fields = rep(1, ncol(marks)), covariates, pp_covariates, ## marks_covariates, tmb_silent = TRUE, nlminb_silent = TRUE, ## ...) ## NULL 3.1.1 Fitting a marked LGCP data(marked, package = &quot;stelfi&quot;) loc.d &lt;- 3 * cbind(c(0, 1, 1, 0, 0), c(0, 0, 1, 1, 0)) domain &lt;- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(loc.d)),&#39;0&#39;))) smesh &lt;- INLA::inla.mesh.2d(loc.domain = loc.d, offset = c(0.3, 1), max.edge = c(0.3, 0.7), cutoff = 0.05) locs &lt;- cbind(x = marked$x, y = marked$y) marks &lt;- cbind(m1 = marked$m1) ## Gaussian parameters &lt;- list(betamarks = matrix(0, nrow = 1, ncol = ncol(marks)) , log_tau = log(1), log_kappa = log(1), marks_coefs_pp = rep(0, ncol(marks)), betapp = 0) fit &lt;- fit_mlgcp(locs = locs, marks = marks, sp = domain, smesh = smesh, parameters = parameters, methods = 0, fields = 0) get_coefs(fit) ## Estimate Std. Error ## betamarks 9.9001308 0.3032841 ## betapp 2.7353453 0.1310755 ## marks_coefs_pp -0.2793251 0.4280345 ## tau 0.1028983 0.0594815 ## kappa 5.8998691 2.6928690 "],["stelfi.html", "Chapter 4 Spatiotemporal self-exciting model 4.1 The fit_stelfi() function 4.2 Hawkes spatial 4.3 Hawkes spde", " Chapter 4 Spatiotemporal self-exciting model 4.1 The fit_stelfi() function args(fit_stelfi) ## function (times, locs, sp, smesh, parameters, covariates, GMRF = FALSE, ## time_independent = TRUE, tmb_silent = TRUE, nlminb_silent = TRUE, ## ...) ## NULL 4.2 Hawkes spatial data(xyt, package = &quot;stelfi&quot;) N &lt;- 50 locs &lt;- data.frame(x = xyt$x[1:N], y = xyt$y[1:N]) times &lt;- xyt$t[1:N] loc.d &lt;- cbind(c(0, 13, 13, 0, 0), c(-3, -3, 3, 3, -3)) domain &lt;- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(loc.d)),&#39;0&#39;))) smesh &lt;- INLA::inla.mesh.2d(boundary = INLA::inla.sp2segment(domain), max.edge = 0.75, cutoff = 0.3) param &lt;- list( mu = 3, alpha = 1, beta = 3, xsigma = 0.2, ysigma = 0.2, rho = 0.8) fit &lt;- fit_stelfi(times = times, locs = locs, sp = domain, smesh = smesh, parameters = param, gaussian = TRUE) get_coefs(fit) ## Estimate Std. Error ## mu 0.2107757 0.10548520 ## coefs -1.5569605 0.50046178 ## alpha 147.3462330 30.26455375 ## beta 147.3462337 30.26455352 ## xsigma 0.6443609 0.08992145 ## ysigma 0.2519132 0.04074381 ## rho -0.1586818 0.19678702 4.3 Hawkes spde ## issues with time.... param &lt;- list( mu = 5, alpha = 1, beta = 3, kappa = 0.9, tau = 1, xsigma = 0.2, ysigma = 0.2, rho = 0.8) fit &lt;- fit_stelfi(times = times, locs = locs, sp = domain, smesh = smesh, parameters = param, gaussian = FALSE) get_coefs(fit) ## Estimate Std. Error ## mu 0.2107757 0.10548520 ## coefs -1.5569605 0.50046178 ## alpha 147.3462330 30.26455375 ## beta 147.3462337 30.26455352 ## xsigma 0.6443609 0.08992145 ## ysigma 0.2519132 0.04074381 ## rho -0.1586818 0.19678702 "],["references.html", "References", " References "]]
